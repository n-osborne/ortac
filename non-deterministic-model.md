# Model testing non-deterministic programs with `ortac`

By non-deterministic here we mean a function which behaviour is not completely
determined by its inputs.

The model testing we have in mind is the one done by QCheckSTM and that is
generated by Ortac/QCheckSTM using Gospel type model and function contracts
to extract the model used in the tests.

Use-cases include function that makes system calls.

We will limit ourselves to the cases where the caller is still informed of the
behaviour through the result of the function (a reasonable expectation).

Let's take the example of a function adding a path to a filesystem. This
function may fail if the disc is full, which is an information we don't want to
include in the logical model of a filesystem.

Ortac/QCheckSTM expect a Gospel postcondition describing how to compute the new
state.

(In the following examples, we will make the assumption that every OCaml
function manipulating a filesystem has its Gospel counterpart manipulating the
logical model of the filesystem.)

So we would want to write something like that:

```ocaml
val add : filesystem -> path -> error option
(*@ o = add fs path
    modifies fs.contents
    ensures fs.contents = match o with
                           | None -> add (old fs.contents) path
                           | Some _ -> old fs.contents *)
```

This is legal Gospel and it makes sense. As we are in a postcondition, the
behaviour has been determined and we have access to this information through
the returned value.

For now, though, the `next_state` function in the `STM.Spec` module type
doesn't have access to the returned value. This can be modified, at the cost of
defining the expected behaviour (the `next_state` function) in term of the
actual behaviour (the actual returned value). This simply remove the
non-determinism.

How the tests will go?

For the sake of example, let's say we also have a `mem` function that checks
whether a path exists in a filesystem:

```ocaml
val mem : filesystem -> path -> bool
(*@ b = mem fs path
    ensures b = mem fs.contents path *)
```

Let's say the `add` function contains a bug: it forgets to return the error and
always returns `None`.
The `next_state` function will include the new path in the logical model of `fs`,
while the actual `fs` won't change.
Now, next time the `mem` function will be called with `path` and `fs`, the
actual result and the logical one will be different.

For comparison purpose, in the case of a function that behaviour can be
determined in term of its input, the `next_state` function would have its
chance to be correct and the user could (should) have added another
postcondition checking the consistancy between the logical model and the
returned value:

```ocaml
val add : filesystem -> path -> error option
(*@ o = add fs path
    modifies fs.contents
    ensures fs.contents = if (* somehow we know if the function will fail *)
                          then fs.contents = old fs.contents
                          else add (old fs.contents) path
    ensures Option.is_none o = mem fs.contents path  *)
```

In this example, the cost is that the bug will be indirectly spotted and
reported on another function. This is not uncommon, a faulty `push` function on
a stack will raise a test failure in another function.

Allowing the `next_state` function to look at the returned value allows the
user to write specification in a way that bugs are indirectly spotted, even
when this is not necessary.

Hence, if we decide to go this way, I would suggest to include some stylish
recommendations in the documentation saying that though the `next_state`
function can have access to the function's result, it is best to avoid using it
when possible.

If we want to avoid having the `next_state` function taking a look at the
returned value, we won't be able to choose right away which state is the right
one.

In term of (denotational) semantic, the semantic of non-determinism is the list
monad:
- the evaluation of a non determinist program is a list of values/results
- composition of two non-determinist programs is done with `flat_map`

This means that the `next_state` function will return a list/set of states.

With that in mind, we could write something like (which reads a bit weird tbh):

```ocaml
val add : filesystem -> path -> error option
(*@ o = add fs path
    modifies fs.contents
    ensures fs.contents = add (old fs.contents) path ||
            fs.contents = old fs.contents
    ensures Option.is_none o = mem fs.contents path  *)
```

What do we know at this point?
Among this set of states, at least one corresponds to the actual sut.
This means that `postcond` should check that the postconditions hold for at
least one of the states.

Now, what happen in the case of our buggy `add` function?

The second postondition will still hold, as the testing tool doesn't have access
to the relation between the new state and the returned value.

But when the `mem` function will be run, the testing tool still has the two
states, one where the logical model of `fs` contains `path` and one where it
doesn't. `mem`'s specification will hold whatever the returned value is and the
bug won't be spotted.

We could use the second postcondition in `add`'s to filter out the states for
which it doesn't hold. But there is no guarantee that the sepcifications
contains postonditions that allow to reduce the set of states to one state.

In conclusion, we have an alternative between:
1. let `next_state` take a look at the returned value to remove non-determinism
2. let `next_state` be non-deterministic and filter out in `postcond`

Both possibilities are conceptually equivalent as in case of a non-deterministic
model, we need to ask the implementation under test to choose a path at every
choice point (see
[there](https://www.microsoft.com/en-us/research/wp-content/uploads/2004/01/OptimalStrategiesForTestingNondeterminsticSystemsISSTA2004.pdf)
for the phrasing)

Though it seems to forbid writing specifications that postpone spotting bugs,
it is not cleat that we can make the latter works. Also, it is asking for an
even weirder specification style.

But I may have missed some problems with the former.
